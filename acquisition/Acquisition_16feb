package gps.acquisition;

import cgra.pe.PETrigonometry;

public class Acquisition {

	// Static input parameters
	private static final int FREQ_STEP_COUNT = 11;
	private static final float FREQ_MOD_MIN = -5000;
	private static final float FREQ_MOD_MAX = 5000;
	private static final float FREQ_MOD_STEP = 1000;
	private static final float FREQ_SAMPLING = 400000;
	private static final float ACQ_THRESHOLD = 0.015f;
	private static final float FPI = (float) Math.PI;

	// Results
	private int dopplerShift = 0;
	private int codeShift = 0;

	// Dynamic input parameters
	private final int sCount;

	// Sample storage for unmodified samples
	private final float[] sample_r;
	private final float[] sample_i;
	private int sampleWriteIndex = 0;

	// Storage for intermediate results
	private final float[] sample_dft_r;
	private final float[] sample_dft_i;

	private final float[] res_r_1;
	private final float[] res_i_1;

	// Code storage (not transformed)
	private final float[] code_r;
	private final float[] code_i;
	private int codeWriteIndex = 0;

	// Storage for DFT(code) results
	private final float[] code_r_dft;
	private final float[] code_i_dft;

	public Acquisition(int nrOfSamples) {
		this.sCount = nrOfSamples;

		this.sample_r = new float[this.sCount];
		this.sample_i = new float[this.sCount];

		this.sample_dft_r = new float[this.sCount];
		this.sample_dft_i = new float[this.sCount];
		this.res_r_1 = new float[this.sCount];
		this.res_i_1 = new float[this.sCount];

		this.code_r = new float[this.sCount];
		this.code_i = new float[this.sCount];
		this.code_r_dft = new float[this.sCount];
		this.code_i_dft = new float[this.sCount];
	}
	
	public void enterSample(float real, float imag) {
		sample_r[sampleWriteIndex] = real;
		sample_i[sampleWriteIndex] = imag;
		++sampleWriteIndex;
	}
	
	public void enterCode(float real, float imag) {
		code_r[codeWriteIndex] = real;
		code_i[codeWriteIndex] = imag;
		++codeWriteIndex;
	}
	
	public boolean startAcquisition() {
		
		final float twoPIdivByN = 2 * FPI / sCount;
		float sumreal_c = 0;
		float sumimag_c = 0;
		float sumreal_x = 0;
		float sumimag_x = 0;
		float pin = 0;
		float cos = 0;
		float sin = 0;
		
		// --- Prepare the code samples by transforming and complex conjugating them
		
		// --- Prepare the samples by by transforming them
		// We do this with the raw samples, no carrier wipe off is performed at this point.
		// The wipe off is happening by applying it in the frequency domain.
				
		// --- Also calculate the signals' power (do not forget the normalisation)
		for (int k = 0; k < sCount; k++) { // For each output element
			pin += sample_r[k] * sample_r[k] + sample_i[k] * sample_i[k];
			sumreal_c = 0;
			sumimag_c = 0;
			sumreal_x = 0;
			sumimag_x = 0;
			for (int t = 0; t < sCount; t++) { // For each input element
				cos =  PETrigonometry.cos(twoPIdivByN * t * k);
				sin =  PETrigonometry.sin(twoPIdivByN * t * k);
				sumreal_c +=  code_r[t]   * cos + code_i[t]   * sin;
				sumimag_c += -code_r[t]   * sin + code_i[t]   * cos;
				sumreal_x +=  sample_r[t] * cos + sample_i[t] * sin;
				sumimag_x += -sample_r[t] * sin + sample_i[t] * cos;
			}
			code_r_dft[k]   =  sumreal_c;
			code_i_dft[k]   = -sumimag_c;
			sample_dft_r[k] =  sumreal_x;
			sample_dft_i[k] =  sumimag_x;
		}
		pin /= sCount;
		
		// --- Calculate Smax on the fly while performing all the other operations
		float smax = 0;
		float fdAtMax = 0;
		int tauAtMax = 0;

		// --- Loop to visit all required frequency shifts (fd)
		float sumreal = 0;
		float sumimag = 0;
		for (int j = 0; j < FREQ_STEP_COUNT; ++j)
		{
			final float fd = FREQ_MOD_MIN + FREQ_MOD_STEP * j;

			{
				final int i = (sCount * (int) fd) / (int) FREQ_SAMPLING;
				int read_index = (sCount+i) % sCount;
				final int first_write_end = sCount - read_index;
				
				
				int k = 0;
				
				// --- Directly multiply both (samples and code) DFT results
				for (; k < first_write_end; ++k)
				{
					res_r_1[k] = sample_dft_r[read_index] * code_r_dft[k] - sample_dft_i[read_index] * code_i_dft[k]; 
					res_i_1[k] = sample_dft_i[read_index] * code_r_dft[k] + sample_dft_r[read_index] * code_i_dft[k];
					++read_index;
				}
				
				read_index = 0; // Wrapping around to zero
				for (; k < sCount; ++k)
				{
					res_r_1[k] = sample_dft_r[read_index] * code_r_dft[k] - sample_dft_i[read_index] * code_i_dft[k]; 
					res_i_1[k] = sample_dft_i[read_index] * code_r_dft[k] + sample_dft_r[read_index] * code_i_dft[k];
					++read_index;
				}
			}

			// ... Samples in res1

			// --- Apply the IDFT to retrieve the results
			for (int k = 0; k < sCount; k++) { // For each output element
				sumreal = 0;
				sumimag = 0;
				
				for (int t = 0; t < sCount; t++) { // For each input element
					// final float angle = constant * t * k;
					sumreal += res_r_1[t] * PETrigonometry.cos(twoPIdivByN * t * k) - res_i_1[t] * PETrigonometry.sin(twoPIdivByN * t * k);
					sumimag += res_r_1[t] * PETrigonometry.sin(twoPIdivByN * t * k) + res_i_1[t] * PETrigonometry.cos(twoPIdivByN * t * k);
				}

				// --- Search the maximum in the resulting vector
				if (smax*sCount*sCount < (sumreal * sumreal + sumimag * sumimag)) {
					smax = (sumreal * sumreal + sumimag * sumimag)/(sCount*sCount);
					fdAtMax = fd;
					tauAtMax = k;
				}
			}
		}

		// --- Save results
		dopplerShift =  (int) fdAtMax;
		codeShift = tauAtMax;

		// --- Calculate the threshold by using the results
		return (smax / pin) > ACQ_THRESHOLD;
	}

		
	
	public int getDopplerverschiebung(){
		return dopplerShift;
	}
	
	public int getCodeVerschiebung(){
		return codeShift;
	}

}
